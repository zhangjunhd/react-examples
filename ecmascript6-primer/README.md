# ECMAScript6入门
![](https://img3.doubanio.com/lpic/s28315395.jpg)

[豆瓣链接](https://book.douban.com/subject/25966265/)

- let和const命令
- 变量的解构赋值
- 字符串的扩展
- 正则的扩展
- 数组的扩展
- [函数的扩展][4]
    - 函数参数的默认值
      - 基本用法
      - 与解构赋值默认值结合使用
      - 参数默认值的位置
      - 函数的length属性
      - 作用域
      - 应用
      - rest参数
    - 扩展运算符
      - 含义
      - 替代数组的apply方法
      - 扩展运算符的应用
      - name属性
    - 箭头函数
      - 基本用法
      - 使用注意点
      - 嵌套的箭头函数
      - 函数绑定
    - 尾调用优化
      - 什么是尾调用？
      - 尾调用优化
      - 尾递归
      - 递归函数的改写
      - 严格模式
      - 尾递归优化的实现
    - 函数参数的尾逗号
- [对象的扩展][3]
  - 属性的简洁表示法
  - 属性名表达式
  - 方法的name属性
  - Object.is()
  - Object.assign()
    - 基本用法
    - 注意点
    - 常见用途
  - 属性的可枚举性
  - 属性的遍历
  - Object.values()，Object.entries()
    - Object.keys()
    - Object.values()
    - Object.entries
  - 对象的扩展运算符
  - Object.getOwnPropertyDescriptors()
- [Symbol][8]
  - 概述
  - 作为属性名的Symbol
  - 实例：消除魔术字符串
  - 属性名的遍历
  - Symbol.for()，Symbol.keyFor()
  - 内置的Symbol值
    - Symbol.hasInstance
    - Symbol.isConcatSpreadable
    - Symbol.species
    - Symbol.match
    - Symbol.replace
    - Symbol.search
    - Symbol.split
    - Symbol.iterator
    - Symbol.toPrimitive
    - Symbol.toStringTag
    - Symbol.unscopables
- [Proxy和Reflect][9]
  - Proxy概述
  - Proxy实例的方法
    - get()
    - apply()
    - has()
    - construct()
    - deleteProperty()
    - defineProperty()
    - enumerate()
    - getOwnPropertyDescriptor()
    - getPrototypeOf()
    - isExtensible()
    - ownKeys()
    - preventExtensions()
    - setPrototypeOf()
    - Proxy.revocable()
  - Reflect概述
  - Reflect对象的方法
- 二进制数组
- Set和Map数据结构
- [Iterator和for...of循环][14]
- [Generator函数][5]
  - 简介
    - 基本概念
    - yield语句
    - 与Iterator接口的关系
    - next方法的参数
    - for...of循环
    - Generator.prototype.throw()
    - Generator.prototype.return()
    - yield*语句
    - 作为对象属性的Generator函数
  - 含义
    - Generator与状态机
    - Generator与协程
    - 应用
- [Promise对象][6]
  - Promise的含义
  - 基本用法
  - Promise.prototype.then()
  - Promise.prototype.catch()
  - Promise.all()
  - Promise.race()
  - Promise.resolve()
  - Promise.reject()
  - 两个有用的附加方法
    - done()
    - finally()
  - 应用
    - 加载图片
    - Generator函数与Promise的结合
  - async函数
- [异步操作和Async函数][7]
  - 回调函数
  - Promise
  - Generator函数
    - 协程
    - Generator函数的概念
    - Generator函数的数据交换和错误处理
    - 异步任务的封装
  - Thunk函数
    - 参数的求值策略
    - Thunk函数的含义
    - JavaScript语言的Thunk函数
    - Thunkify模块
    - Generator 函数的流程管理
    - Thunk函数的自动流程管理
  - co模块
    - 基本用法
    - co模块的原理
    - 基于Promise对象的自动执行
    - co模块的源码
    - 处理并发的异步操作
  - async函数
    - 含义
    - async函数的实现
    - async函数的用法
    - 注意点
    - 与Promise、Generator的比较
- [Class][2]
  - Class基本语法
    - 概述
    - constructor方法
    - 类的实例对象
    - name属性
    - Class表达式
    - 不存在变量提升
    - 严格模式
  - Class的继承
    - 基本用法
    - 类的prototype属性和\_\_proto\_\_属性
    - Extends 的继承目标
    - Object.getPrototypeOf()
    - super关键字
    - 实例的\_\_proto\_\_属性
    - 原生构造函数的继承
    - Class的取值函数（getter）和存值函数（setter）
    - Class的Generator方法
    - Class的静态方法
    - Class的静态属性和实例属性
    - new.target属性
    - Mixin模式的实现
- [Decorator][10]
  - 类的修饰
  - 方法的修饰
  - 为什么修饰器不能用于函数？
  - core-decorators.js
  - 使用修饰器实现自动发布事件
  - Mixin
  - Trait
  - Babel转码器的支持
- [Module][11]
- [函数式编程][12]
- [Mixin][13]
- [编程风格][1]
  - 块级作用域
    - let取代var
    - 全局常量和线程安全
  - 字符串
  - 解构赋值
  - 对象
  - 数组
  - 函数
  - Map结构
  - Class
  - 模块
  - ESLint的使用

[1]: coding-style.md
[2]: class.md
[3]: object-extend.md
[4]: function-extend.md
[5]: generator-function.md
[6]: promise-object.md
[7]: async.md
[8]: symbol.md
[9]: proxy-reflect.md
[10]: decorator.md
[11]: module.md
[12]: functional-programming.md
[13]: mixin.md
[14]: iterator.md
