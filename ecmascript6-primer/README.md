# ECMAScript6入门
![](https://img3.doubanio.com/lpic/s28315395.jpg)

[豆瓣链接](https://book.douban.com/subject/25966265/)

- [let和const命令][15]
  - let命令
    - 基本用法
    - 不存在变量提升
    - 暂时性死区
    - 不允许重复声明
  - 块级作用域
    - 为什么需要块级作用域？
    - ES6的块级作用域
  - const命令
  - 全局对象的属性
- [变量的解构赋值][16]
  - 数组的解构赋值
    - 基本用法
    - 默认值
  - 对象的解构赋值
  - 字符串的解构赋值
  - 数值和布尔值的解构赋值
  - 函数参数的解构赋值
  - 圆括号问题
    - 不能使用圆括号的情况
    - 可以使用圆括号的情况
  - 用途
- [字符串的扩展][17]
  - 字符的Unicode表示法
  - codePointAt()
  - String.fromCodePoint()
  - 字符串的遍历器接口
  - at()
  - normalize()
  - includes(), startsWith(), endsWith()
  - repeat()
  - padStart()，padEnd()
  - 模板字符串
  - 实例：模板编译
  - 标签模板
  - String.raw()
- [正则的扩展][18]
  - RegExp构造函数
  - 字符串的正则方法
  - u修饰符
  - y修饰符
  - sticky属性
  - flags属性
  - RegExp.escape()
  - 后行断言
- [数组的扩展][19]
  - Array.from()
  - Array.of()
  - 数组实例的copyWithin()
  - 数组实例的find()和findIndex()
  - 数组实例的fill()
  - 数组实例的entries()，keys()和values()
  - 数组实例的includes()
  - 数组的空位
- [函数的扩展][4]
    - 函数参数的默认值
      - 基本用法
      - 与解构赋值默认值结合使用
      - 参数默认值的位置
      - 函数的length属性
      - 作用域
      - 应用
      - rest参数
    - 扩展运算符
      - 含义
      - 替代数组的apply方法
      - 扩展运算符的应用
      - name属性
    - 箭头函数
      - 基本用法
      - 使用注意点
      - 嵌套的箭头函数
      - 函数绑定
    - 尾调用优化
      - 什么是尾调用？
      - 尾调用优化
      - 尾递归
      - 递归函数的改写
      - 严格模式
      - 尾递归优化的实现
    - 函数参数的尾逗号
- [对象的扩展][3]
  - 属性的简洁表示法
  - 属性名表达式
  - 方法的name属性
  - Object.is()
  - Object.assign()
    - 基本用法
    - 注意点
    - 常见用途
  - 属性的可枚举性
  - 属性的遍历
  - Object.values()，Object.entries()
    - Object.keys()
    - Object.values()
    - Object.entries
  - 对象的扩展运算符
  - Object.getOwnPropertyDescriptors()
- [Symbol][8]
  - 概述
  - 作为属性名的Symbol
  - 实例：消除魔术字符串
  - 属性名的遍历
  - Symbol.for()，Symbol.keyFor()
  - 内置的Symbol值
    - Symbol.hasInstance
    - Symbol.isConcatSpreadable
    - Symbol.species
    - Symbol.match
    - Symbol.replace
    - Symbol.search
    - Symbol.split
    - Symbol.iterator
    - Symbol.toPrimitive
    - Symbol.toStringTag
    - Symbol.unscopables
- [Proxy和Reflect][9]
  - Proxy概述
  - Proxy实例的方法
    - get()
    - apply()
    - has()
    - construct()
    - deleteProperty()
    - defineProperty()
    - enumerate()
    - getOwnPropertyDescriptor()
    - getPrototypeOf()
    - isExtensible()
    - ownKeys()
    - preventExtensions()
    - setPrototypeOf()
    - Proxy.revocable()
  - Reflect概述
  - Reflect对象的方法
- [二进制数组][20]
  - ArrayBuffer对象
    - 概述
    - ArrayBuffer.prototype.byteLength
    - ArrayBuffer.prototype.slice()
    - ArrayBuffer.isView()
  - TypedArray视图
    - 概述
    - 构造函数
    - 数组方法
    - 字节序
    - BYTES_PER_ELEMENT属性
    - ArrayBuffer与字符串的互相转换
    - 溢出
    - TypedArray.prototype.buffer
    - TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset
    - TypedArray.prototype.length
    - TypedArray.prototype.set()
    - TypedArray.prototype.subarray()
    - TypedArray.prototype.slice()
    - TypedArray.of()
    - TypedArray.from()
  - 复合视图
  - DataView视图
  - 二进制数组的应用
    - AJAX
    - Canvas
    - WebSocket
    - Fetch API
    - File API
- [Set和Map数据结构][21]
  - Set
    - 基本用法
    - Set实例的属性和方法
    - 遍历操作
    - WeakSet
  - Map
    - Map结构的目的和基本用法
    - 实例的属性和操作方法
    - 遍历方法
    - 与其他数据结构的互相转换
    - WeakMap
- [Iterator和for...of循环][14]
  - Iterator（遍历器）的概念
  - 数据结构的默认Iterator接口
  - 调用Iterator接口的场合
  - 字符串的Iterator接口
  - Iterator接口与Generator函数
  - 遍历器对象的return()，throw()
  - for...of循环
  - 数组
  - Set和Map结构
  - 计算生成的数据结构
  - 类似数组的对象
  - 对象
  - 与其他遍历语法的比较
- [Generator函数][5]
  - 简介
    - 基本概念
    - yield语句
    - 与Iterator接口的关系
    - next方法的参数
    - for...of循环
    - Generator.prototype.throw()
    - Generator.prototype.return()
    - yield*语句
    - 作为对象属性的Generator函数
  - 含义
    - Generator与状态机
    - Generator与协程
    - 应用
- [Promise对象][6]
  - Promise的含义
  - 基本用法
  - Promise.prototype.then()
  - Promise.prototype.catch()
  - Promise.all()
  - Promise.race()
  - Promise.resolve()
  - Promise.reject()
  - 两个有用的附加方法
    - done()
    - finally()
  - 应用
    - 加载图片
    - Generator函数与Promise的结合
  - async函数
- [异步操作和Async函数][7]
  - 回调函数
  - Promise
  - Generator函数
    - 协程
    - Generator函数的概念
    - Generator函数的数据交换和错误处理
    - 异步任务的封装
  - Thunk函数
    - 参数的求值策略
    - Thunk函数的含义
    - JavaScript语言的Thunk函数
    - Thunkify模块
    - Generator 函数的流程管理
    - Thunk函数的自动流程管理
  - co模块
    - 基本用法
    - co模块的原理
    - 基于Promise对象的自动执行
    - co模块的源码
    - 处理并发的异步操作
  - async函数
    - 含义
    - async函数的实现
    - async函数的用法
    - 注意点
    - 与Promise、Generator的比较
- [Class][2]
  - Class基本语法
    - 概述
    - constructor方法
    - 类的实例对象
    - name属性
    - Class表达式
    - 不存在变量提升
    - 严格模式
  - Class的继承
    - 基本用法
    - 类的prototype属性和\_\_proto\_\_属性
    - Extends 的继承目标
    - Object.getPrototypeOf()
    - super关键字
    - 实例的\_\_proto\_\_属性
    - 原生构造函数的继承
    - Class的取值函数（getter）和存值函数（setter）
    - Class的Generator方法
    - Class的静态方法
    - Class的静态属性和实例属性
    - new.target属性
    - Mixin模式的实现
- [Decorator][10]
  - 类的修饰
  - 方法的修饰
  - 为什么修饰器不能用于函数？
  - core-decorators.js
  - 使用修饰器实现自动发布事件
  - Mixin
  - Trait
  - Babel转码器的支持
- [Module][11]
  - 严格模式
  - export命令
  - import命令
  - 模块的整体加载
  - export default命令
  - 模块的继承
  - ES6模块加载的实质
  - 循环加载
  - CommonJS模块的加载原理
  - CommonJS模块的循环加载
  - ES6模块的循环加载
  - 跨模块常量
  - ES6模块的转码
    - ES6 module transpiler
    - SystemJS
- [函数式编程][12]
  - 函数合成
  - 参数倒置
  - 执行边界
  - 队列操作
  - 合并操作
  - 配对操作
  - 参考链接
- [Mixin][13]
  - 含义
  - Trait
- [编程风格][1]
  - 块级作用域
    - let取代var
    - 全局常量和线程安全
  - 字符串
  - 解构赋值
  - 对象
  - 数组
  - 函数
  - Map结构
  - Class
  - 模块
  - ESLint的使用

[1]: coding-style.md
[2]: class.md
[3]: object-extend.md
[4]: function-extend.md
[5]: generator-function.md
[6]: promise-object.md
[7]: async.md
[8]: symbol.md
[9]: proxy-reflect.md
[10]: decorator.md
[11]: module.md
[12]: functional-programming.md
[13]: mixin.md
[14]: iterator.md
[15]: let-const.md
[16]: variable.md
[17]: string-extend.md
[18]: regex-extend.md
[19]: array-extend.md
[20]: binary-array.md
[21]: set-and-map.md
